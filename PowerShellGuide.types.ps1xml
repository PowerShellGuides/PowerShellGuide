<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 1.9.9: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>PowerShell.Guide.Topic.File</Name>
    <Members>
      <ScriptMethod>
        <Name>FindCodeBlocks</Name>
        <Script>
                        $codeFenceRegex = [Regex]::new(@'
(?&gt;
    (?&lt;FenceChar&gt;[`\~]){3}    # Code fences start with tildas or backticks, repeated at least 3 times
(?&lt;Language&gt;                  # Match a specific language
PowerShell
)
[\s-[\r\n]]{0,}               # Match but do not capture initial whitespace.
(?&lt;Code&gt;                      # Capture the &lt;Code&gt; block
    (?:.|\s){0,}?             # This is anything until
    (?=\z|\k&lt;FenceChar&gt;{3})   # the end of the string or the same matching fence chars
)
(?&gt;\z|\k&lt;FenceChar&gt;{3})
)
'@, 'IgnoreCase,IgnorePatternWhitespace,Singleline')

$codeFenceRegex.Matches($this.Content)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>FindHyperlinks</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Matches a Markdown Link
.DESCRIPTION
    Matches a Markdown Link.  Can customize the link text and link url.
.NOTES
    This only matches simple markdown links.  It does not currently match links with titles.
#&gt;
param(
# The text of the link.
$LinkText  = '[^\]\r\n]+',

# The link URI.
[Alias('LinkUrl')]
$LinkUri   = '[^\)\r\n]+'
)

[Regex]::new(@"
(?&lt;IsImage&gt;\!)?    # If there is an exclamation point, then it is an image link
\[                 # Markdown links start with a bracket
(?&lt;Text&gt;$LinkText)
\]                 # anything until the end bracket is the link text.
\(                 # The link uri is within parenthesis
(?&lt;Uri&gt;$LinkUri)
\)                 # anything until the closing parenthesis is the link uri.
"@, 'IgnoreCase, IgnorePatternWhitespace').Matches($this.Content)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>FindReferences</Name>
        <Script>
                        $content = $this.Content
$PowerShellGuide  = Get-PowerShellGuide
$topicReference   = @{}
foreach ($guideTopic in $PowerShellGuide.AllTopics) {
    if ($guideTopic.Fullname -eq $this.Fullname) { continue } # avoid self-references
    foreach ($alias in $guideTopic.Aliases) {
        $topicReference[$alias] = $guideTopic
    }
}

$sortedKeys = $topicReference.Keys | Sort-Object Length, { $_ } -Descending



$anyMatches = [Regex]::new("(?&lt;=[\s\&gt;'`"_])(?&gt;$(
    @(foreach ($k in $sortedKeys) {
        [Regex]::Escape($k) -replace '\\\s', '[\s\-_]'
    }) -join '|'
))(?=[\s\&gt;'`"_\.,])", 'IgnoreCase')



foreach ($match in $anyMatches.Matches($content)) {
    $topicAlias = $match -replace '[\s\-_]',' '
    [PSCustomObject]@{
        PSTypeName = 'PowerShell.Guide.Reference'
        Match      = $match
        TopicName  = $topicReference["$topicAlias"].TopicName
        TopicFile  = $topicReference["$topicAlias"]
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Content</Name>
        <GetScriptBlock>
                        [IO.File]::ReadAllText($this.Fullname)
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Link</Name>
        <GetScriptBlock>
                        $link = $this.RelativePath -replace '[\-_\s]', '-' -replace '\.md$', ''
if ($link -match '[\\/]') {
    $linkParts = @($link -split '[\\/]')
    if ($linkParts[-1] -eq $linkParts[-2]) {
        $linkParts[0..$($linkParts.Length - 2)] -join '/'
    } else {
        $linkParts -join '/'
    }
} else {
    $link
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RelativePath</Name>
        <GetScriptBlock>
                        @($this.Fullname -split '[\\/]Guide[\\/]', 2)[1]
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TopicName</Name>
        <GetScriptBlock>
                        $this.Name -replace '[_-]', ' ' -replace '\.md$'
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>
